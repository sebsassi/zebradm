<!doctype html>
<html class="no-js" lang="en" data-content_root="./">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="index" title="Index" href="genindex.html" /><link rel="search" title="Search" href="search.html" /><link rel="next" title="Library reference" href="reference.html" /><link rel="prev" title="Usage – Integrating a Radon transform" href="usage.html" />

    <!-- Generated with Sphinx 8.2.3 and Furo 2024.08.06 -->
        <title>Example: DM–nucleon scattering - zebradm 0.1.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=8f2a1f02" />
    <link rel="stylesheet" type="text/css" href="_static/styles/furo.css?v=354aac6f" />
    <link rel="stylesheet" type="text/css" href="_static/styles/furo-extensions.css?v=302659d7" />
    
    


<style>
  body {
    --color-code-background: #f8f8f8;
  --color-code-foreground: black;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-with-moon" viewBox="0 0 24 24">
    <title>Auto light/dark, in light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round"
      class="icon-custom-derived-from-feather-sun-and-tabler-moon">
      <path style="opacity: 50%" d="M 5.411 14.504 C 5.471 14.504 5.532 14.504 5.591 14.504 C 3.639 16.319 4.383 19.569 6.931 20.352 C 7.693 20.586 8.512 20.551 9.25 20.252 C 8.023 23.207 4.056 23.725 2.11 21.184 C 0.166 18.642 1.702 14.949 4.874 14.536 C 5.051 14.512 5.231 14.5 5.411 14.5 L 5.411 14.504 Z"/>
      <line x1="14.5" y1="3.25" x2="14.5" y2="1.25"/>
      <line x1="14.5" y1="15.85" x2="14.5" y2="17.85"/>
      <line x1="10.044" y1="5.094" x2="8.63" y2="3.68"/>
      <line x1="19" y1="14.05" x2="20.414" y2="15.464"/>
      <line x1="8.2" y1="9.55" x2="6.2" y2="9.55"/>
      <line x1="20.8" y1="9.55" x2="22.8" y2="9.55"/>
      <line x1="10.044" y1="14.006" x2="8.63" y2="15.42"/>
      <line x1="19" y1="5.05" x2="20.414" y2="3.636"/>
      <circle cx="14.5" cy="9.55" r="3.6"/>
    </svg>
  </symbol>
  <symbol id="svg-moon-with-sun" viewBox="0 0 24 24">
    <title>Auto light/dark, in dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round"
      class="icon-custom-derived-from-feather-sun-and-tabler-moon">
      <path d="M 8.282 7.007 C 8.385 7.007 8.494 7.007 8.595 7.007 C 5.18 10.184 6.481 15.869 10.942 17.24 C 12.275 17.648 13.706 17.589 15 17.066 C 12.851 22.236 5.91 23.143 2.505 18.696 C -0.897 14.249 1.791 7.786 7.342 7.063 C 7.652 7.021 7.965 7 8.282 7 L 8.282 7.007 Z"/>
      <line style="opacity: 50%" x1="18" y1="3.705" x2="18" y2="2.5"/>
      <line style="opacity: 50%" x1="18" y1="11.295" x2="18" y2="12.5"/>
      <line style="opacity: 50%" x1="15.316" y1="4.816" x2="14.464" y2="3.964"/>
      <line style="opacity: 50%" x1="20.711" y1="10.212" x2="21.563" y2="11.063"/>
      <line style="opacity: 50%" x1="14.205" y1="7.5" x2="13.001" y2="7.5"/>
      <line style="opacity: 50%" x1="21.795" y1="7.5" x2="23" y2="7.5"/>
      <line style="opacity: 50%" x1="15.316" y1="10.184" x2="14.464" y2="11.036"/>
      <line style="opacity: 50%" x1="20.711" y1="4.789" x2="21.563" y2="3.937"/>
      <circle style="opacity: 50%" cx="18" cy="7.5" r="2.169"/>
    </svg>
  </symbol>
  <symbol id="svg-pencil" viewBox="0 0 24 24">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-pencil-code">
      <path d="M4 20h4l10.5 -10.5a2.828 2.828 0 1 0 -4 -4l-10.5 10.5v4" />
      <path d="M13.5 6.5l4 4" />
      <path d="M20 21l2 -2l-2 -2" />
      <path d="M17 17l-2 2l2 2" />
    </svg>
  </symbol>
  <symbol id="svg-eye" viewBox="0 0 24 24">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-eye-code">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M10 12a2 2 0 1 0 4 0a2 2 0 0 0 -4 0" />
      <path
        d="M11.11 17.958c-3.209 -.307 -5.91 -2.293 -8.11 -5.958c2.4 -4 5.4 -6 9 -6c3.6 0 6.6 2 9 6c-.21 .352 -.427 .688 -.647 1.008" />
      <path d="M20 21l2 -2l-2 -2" />
      <path d="M17 17l-2 2l2 2" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>

<a class="skip-to-content muted-link" href="#furo-main-content">Skip to content</a>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="index.html"><div class="brand">zebradm 0.1.0 documentation</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
          <svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand" href="index.html">
  
  
  <span class="sidebar-brand-text">zebradm 0.1.0 documentation</span>
  
</a><form class="sidebar-search-container" method="get" action="search.html" role="search">
  <input class="sidebar-search" placeholder="Search" name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="getting_started.html">Getting started</a></li>
<li class="toctree-l1"><a class="reference internal" href="introduction.html">Theory – Zernike-based Radon transforms</a></li>
<li class="toctree-l1"><a class="reference internal" href="usage.html">Usage – Integrating a Radon transform</a></li>
<li class="toctree-l1 current current-page"><a class="current reference internal" href="#">Example: DM–nucleon scattering</a></li>
<li class="toctree-l1"><a class="reference internal" href="reference.html">Library reference</a></li>
</ul>

</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          <div class="view-this-page">
  <a class="muted-link" href="_sources/dm_example.rst.txt" title="View this page">
    <svg><use href="#svg-eye"></use></svg>
    <span class="visually-hidden">View this page</span>
  </a>
</div>
<div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
              <svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main" id="furo-main-content">
          <section id="example-dm-nucleon-scattering">
<h1>Example: DM–nucleon scattering<a class="headerlink" href="#example-dm-nucleon-scattering" title="Link to this heading">¶</a></h1>
<p>In the nonrelativistic effective theory framework of nuclear scattering, the direct detection
scattering rate for dark matter scattering off nuclear targets can be expressed in the form</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\frac{d^2R_S}{dEd\Omega} = \frac{1}{64\pi^2}\frac{\rho_0}{m_\text{DM}^3m_\text{N}^2}(
    F(q^2)\mathcal{R}[f](\hat{q},v_\text{min}) + F_\perp(q^2)\mathcal{R}_\perp[f](\hat{q},v_\text{min})).\]</div>
</div>
<p>Here <span class="math notranslate nohighlight">\(\rho_0\)</span> is the local dark matter density, <span class="math notranslate nohighlight">\(m_\text{DM}\)</span> is the mass of the dark
matter particle, <span class="math notranslate nohighlight">\(m_\text{N}\)</span> is the mass of the target nucleus, <span class="math notranslate nohighlight">\(\vec{q}\)</span> is the
momentum transfer to the nucleus, and</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[v_\text{min} = \frac{q}{2\mu_\text{DM,N}},\]</div>
</div>
<p>with <span class="math notranslate nohighlight">\(\mu_\text{DM,N}\)</span> is the reduced mass of the DM–nucleus system. See the article
<a class="reference external" href="https://example.com">arxiv:xxxx.xxxx</a> for a detailed discussion.</p>
<p>The functions <span class="math notranslate nohighlight">\(F(q^2)\)</span> and <span class="math notranslate nohighlight">\(F_\perp(q^2)\)</span> depend on the effective theory couplings of
dark matter to nucleons, and on the nuclear response functions. We do not concern ourselves with
their details here, however, but it is worth noting that in the limit of small momentum transfer
they can be regarded as polynomials in <span class="math notranslate nohighlight">\(q^2\)</span>.</p>
<p>The functions <span class="math notranslate nohighlight">\(\mathcal{R}[f]\)</span> and <span class="math notranslate nohighlight">\(\mathcal{R}_\perp[f]\)</span> denote the Radon and
transverse Radon transforms of the dark matter velocity distribution <span class="math notranslate nohighlight">\(f\)</span> in the laboratory
frame, as defined in the theory section.</p>
<p>This example demonstrates how this library could be used to calculate the energy-differential event rate</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\frac{dR}{dE} = \int S(\vec{q})\frac{d^2R_S}{dEd\Omega}\,d\Omega.\]</div>
</div>
<section id="disclaimer">
<h2>Disclaimer<a class="headerlink" href="#disclaimer" title="Link to this heading">¶</a></h2>
<p>There are a number of input quantities whose origins we need to consider for the full calculation.
Apart from the parameters discussed above, there is also the laboratory velocity relative to the
dark matter distribution, <span class="math notranslate nohighlight">\(\vec{v}_\text{lab}\)</span>, which appears in the formula for the lab
frame velocity distribution <span class="math notranslate nohighlight">\(f(\vec{v} + \vec{v}_\text{lab})\)</span>.</p>
<p>Furthermore, there is a hidden parameter, which is the relative orientation of the coordinate
systems in which the distribution <span class="math notranslate nohighlight">\(f(\vec{v})\)</span> is defined, and the coordinate system of the
response <span class="math notranslate nohighlight">\(S(\vec{q})\)</span>. Conventionally, the former is in galactic coordinates, while the
latter is in lab coordinates, and this needs to be dealt with.</p>
<p>This library is primarily focused on the computationally challenging part of evaluating the Radon
transforms in a timely manner, and does not provide general facilities for evaluation of the other
input parameters. Therefore, this example is about what form the inputs will need to take so that
they can be used with this library. Parts that are outside the scope of this library are assumed as
given.</p>
</section>
<section id="inputs">
<h2>Inputs<a class="headerlink" href="#inputs" title="Link to this heading">¶</a></h2>
<p>We will assume that there exists a number of functions that evaluate the input parameters we need
to compute the angle-integrated Radon transforms, and it is up to the user of the lbrary how those
functions are implemented in practice. These magic functions are as follows</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span>
<span class="n">time_interval</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string_view</span><span class="w"> </span><span class="n">start</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string_view</span><span class="w"> </span><span class="n">end</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="w"> </span><span class="n">count</span><span class="p">);</span>

<span class="n">std</span><span class="o">::</span><span class="n">vecto</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="o">&gt;&gt;</span>
<span class="n">compute_lab_velocities_equatorial</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">span</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">times</span><span class="p">);</span>

<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">compute_earth_rotation_angles</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">span</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">times</span><span class="p">);</span>
<span class="n">zdm</span><span class="o">::</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="n">rotation_matrix_from_equatorial_to_galactic</span><span class="p">();</span>
<span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="n">euler_angles_from_lab_to_polar</span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="n">lon</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">lat</span><span class="p">);</span>

<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;&gt;</span>
<span class="n">compute_eft_responses</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">span</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">momentum_transfers</span><span class="p">);</span>

<span class="n">zdm</span><span class="o">::</span><span class="n">SHExpansionVector</span>
<span class="nf">get_detector_response</span><span class="p">(</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">span</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">momentum_transfers</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="w"> </span><span class="n">resp_order</span><span class="p">);</span>

<span class="n">DistributionParams</span><span class="w"> </span><span class="nf">get_distribution_params</span><span class="p">();</span>

<span class="kt">double</span><span class="w"> </span><span class="nf">velocity_distribution</span><span class="p">(</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">velocity</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">DistributionParams</span><span class="o">&amp;</span><span class="w"> </span><span class="n">params</span><span class="p">);</span>
</pre></div>
</div>
<p>This is approximately the scope of things we’d need to implement to get to the point where we can
evaluate the angle-integrated Radon transform. Some of the the things here have been simplified so
that we don’t get bogged down in irrelevant details. For example, in reality the function
<code class="docutils literal notranslate"><span class="pre">compute_eft_responses</span></code> would also take as parameters the EFT coefficients, parameters of the
target nucleus, and so on. But in this example, we do not care so much about the implementations or
inputs to these functions, just their outputs.</p>
<p>There is already one important aspect that can be observed here. For performance reasons, the
library requires the velocity distribution and response to have coordinate systems whose z-axes are
aligned, but which may differ by an angle in the xy-plane. This is no problem, because the Earth’s
axis of rotation does not change, to a good approximation, on time scales at which direct detection
experiments operate. Therefore, aligning the z-axes of the coordinates of the velocity distribution
only requires a time-independent rotation on both. The velocity distribution is rotated to the
equatorial coordinate system (technically, the geocentric celestial refernce system), and the
response is rotated to a horizontal coordinate system at the north pole (which I call “polar”
coordinate system here for brevity, and which technically is the international terrestrial reference
system). These two coordinate systems then differ by the Earth rotation angle.</p>
<p>The velocity distribution here is assumed to have a parametric formula, but the response is defined
a bit more ambiguously, because in reality it would likely be generated from some numerical data,
so we just have a function, which gives a collection of spherical harmonic expansions given a
collection of momentum transfer magnitudes.</p>
<p>To avoid having to specify a definition of time, its origin and units, I have defined a function,
which just gives us a number of times given a start date, end date, and a count</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">times</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">time_interval</span><span class="p">(</span><span class="s">&quot;2000-01-01&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;2001-01-02&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">24</span><span class="p">);</span>
</pre></div>
</div>
<p>Doesn’t matter what units these are in, because we will just use them to compute things we actually
care about</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">v_lab_eq</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lab_velocities_equatorial</span><span class="p">(</span><span class="n">times</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">era</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">earth_rotation_angles</span><span class="p">(</span><span class="n">times</span><span class="p">);</span>
</pre></div>
</div>
<p>Then we have the static coordinate transforms</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">zdm</span><span class="o">::</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="n">equ_to_gal</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rotation_matrix_from_equatorial_to_galactic</span><span class="p">();</span>

<span class="k">constexpr</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">lon</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.5</span><span class="o">*</span><span class="n">std</span><span class="o">::</span><span class="n">numbers</span><span class="o">::</span><span class="n">pi</span><span class="p">;</span>
<span class="k">constexpr</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">lat</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.25</span><span class="o">*</span><span class="n">std</span><span class="o">::</span><span class="n">numbers</span><span class="o">::</span><span class="n">pi</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="n">lab_to_polar</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">euler_angles_from_lab_to_polar</span><span class="p">(</span><span class="n">lon</span><span class="p">,</span><span class="w"> </span><span class="n">lat</span><span class="p">);</span>
</pre></div>
</div>
<p>Apart from a very conveniently located detector site, it’s notable that we define one of these
rotations in terms of a rotation matrix, and the other in terms of Euler angles. The reason for
that is that we are going to apply them under different circumstances.</p>
<p>Next we wish to generate a collection of energies at which the energy differential event rate will
be evaluated. However, something we need to take into account is that the energy is bound by the
inequality</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[v_\text{min} \leq v_\text{lab} + v_\text{esc},\]</div>
</div>
<p>where <span class="math notranslate nohighlight">\(v_\text{esc}\)</span> is the escape velocity. When this inequality does not hold, the event
rate is zero, so there is no point computing the event rate outside this range. We could just
generate the <span class="math notranslate nohighlight">\(v_\text{min}\)</span> values directly, but that may not be desirable if we want the
energies to be equispaced, since <span class="math notranslate nohighlight">\(v_\text{min}\)</span> is not a linear function of energy</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[v_\text{min} = \sqrt{\frac{m_\text{N}E}{2\mu_\text{DM,N}}}.\]</div>
</div>
<p>However, this gives a straightforward upperbound for the energy</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[E \leq \frac{2\mu_\text{DM,N}}{m_\text{N}}(v_\text{lab} + v_\text{esc})^2.\]</div>
</div>
<p>This is straightforward enough to implement here</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">generate_energies</span><span class="p">(</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">reduced_mass</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">nuclear_mass</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">v_lab_max</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">v_esc</span><span class="p">,</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="w"> </span><span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">v_minmax</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v_lab_max</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">v_esc</span><span class="p">;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">emax</span>
<span class="w">        </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="n">reduced_mass</span><span class="o">/</span><span class="n">nuclear_mass</span><span class="p">)</span><span class="o">*</span><span class="n">v_minmax</span><span class="o">*</span><span class="n">v_minmax</span><span class="p">;</span>

<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">energies</span><span class="p">(</span><span class="n">count</span><span class="p">);</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">count</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="w">        </span><span class="n">energies</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">emax</span><span class="o">*</span><span class="kt">double</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">/</span><span class="kt">double</span><span class="p">(</span><span class="n">count</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">energies</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">vmin_from</span><span class="p">(</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">span</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">energies</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">reduced_mass</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">nuclear_mass</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">prefactor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nuclear_mass</span><span class="o">/</span><span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="n">reduced_mass</span><span class="p">);</span>

<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">vmin</span><span class="p">(</span><span class="n">energies</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">count</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="w">        </span><span class="n">vmin</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">sqrt</span><span class="p">(</span><span class="n">prefactor</span><span class="o">*</span><span class="n">energies</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">vmin</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">momentum_transfers_from</span><span class="p">(</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">span</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">energies</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">nuclear</span><span class="w"> </span><span class="n">mass</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">prefactor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">2.0</span><span class="o">*</span><span class="n">nuclear_mass</span><span class="p">;</span>

<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">momentum_transfers</span><span class="p">(</span><span class="n">energies</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">count</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="w">        </span><span class="n">momentum_transfers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">sqrt</span><span class="p">(</span><span class="n">prefactor</span><span class="o">*</span><span class="n">energies</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">momentum_transfers</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The value of <code class="docutils literal notranslate"><span class="pre">v_lab_max</span></code> we need to calculate from the list of lab velocities we generated above</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">double</span><span class="w"> </span><span class="nf">maximum_lab_velocity</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">span</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">lab_velocities</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">v_lab_sq_max</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">v_lab</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">lab_velocities</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">v_sq</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">zdm</span><span class="o">::</span><span class="n">dot</span><span class="p">(</span><span class="n">v_lab</span><span class="p">,</span><span class="w"> </span><span class="n">v_lab</span><span class="p">);</span>
<span class="w">        </span><span class="n">v_lab_sq_max</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">max</span><span class="p">(</span><span class="n">v_lab_sq_max</span><span class="p">,</span><span class="w"> </span><span class="n">v_sq</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">sqrt</span><span class="p">(</span><span class="n">v_lab_sq_max</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Now we can generate the <span class="math notranslate nohighlight">\(v_\text{min}\)</span> and momentum transfer values we are after</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">energies</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">generate_energies</span><span class="p">(</span>
<span class="w">    </span><span class="n">reduced_mass</span><span class="p">,</span><span class="w"> </span><span class="n">nuclear_mass</span><span class="p">,</span><span class="w"> </span><span class="n">maximum_lab_velocity</span><span class="p">(</span><span class="n">v_lab_eq</span><span class="p">),</span><span class="w"> </span><span class="n">v_esc</span><span class="p">,</span><span class="w"> </span><span class="mi">50</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">v_min</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vmin_from</span><span class="p">(</span><span class="n">energies</span><span class="p">,</span><span class="w"> </span><span class="n">reduced_mass</span><span class="p">,</span><span class="w"> </span><span class="n">nuclear_mass</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">momentum_transfers</span>
<span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="n">momentum_transfer_from</span><span class="p">(</span><span class="n">energies</span><span class="p">,</span><span class="w"> </span><span class="n">nuclear_mass</span><span class="p">);</span>
</pre></div>
</div>
</section>
<section id="distribution-and-response">
<h2>Distribution and response<a class="headerlink" href="#distribution-and-response" title="Link to this heading">¶</a></h2>
<p>With the momentum transfers, we can get the detector response</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">zdm</span><span class="o">::</span><span class="n">SHExpansionVector</span><span class="w"> </span><span class="n">resp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_detector_response</span><span class="p">(</span><span class="n">momentum_transfers</span><span class="p">);</span>
</pre></div>
</div>
<p>Now, this response is defined in the lab frame, but we want it in the polar frame, so we need to
rotate it. For this we can use the class <code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">zest::Rotor</span></code>, which enables rotations of
spherical harmonic expansions</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">zest</span><span class="o">::</span><span class="n">Rotor</span><span class="w"> </span><span class="nf">rotor</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">max</span><span class="p">(</span><span class="n">resp_order</span><span class="p">,</span><span class="w"> </span><span class="n">disp_order</span><span class="p">));</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">resp</span><span class="p">.</span><span class="n">extent</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="w">    </span><span class="n">rotor</span><span class="p">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">resp</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="w"> </span><span class="n">lab_to_polar</span><span class="p">,</span><span class="w"> </span><span class="n">zest</span><span class="o">::</span><span class="n">RotationType</span><span class="o">::</span><span class="n">coordinate</span><span class="p">);</span>
</pre></div>
</div>
<p>When it comes to the velocity distribution, we need it to have a specific function signature, which
only takes as arguments the spherical coordinates of the velocity itself. The easiest way to do this
is to wrap it in a lambda</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">const</span><span class="w"> </span><span class="n">zdm</span><span class="o">::</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="n">rot_equ_to_gal</span>
<span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="n">rotation_matrix_from_equatorial_to_galactic</span><span class="p">();</span>
<span class="k">const</span><span class="w"> </span><span class="n">DistributionParams</span><span class="w"> </span><span class="n">params</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_distribution_params</span><span class="p">();</span>
<span class="k">auto</span><span class="w"> </span><span class="n">wrapped_distribution</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="kt">double</span><span class="w"> </span><span class="n">lat</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">colat</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">r</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="n">v_equ</span>
<span class="w">        </span><span class="o">=</span><span class="w"> </span><span class="n">zdm</span><span class="o">::</span><span class="n">coordinates</span><span class="o">::</span><span class="n">spherical_to_cartesian_phys</span><span class="p">(</span><span class="n">lat</span><span class="p">,</span><span class="w"> </span><span class="n">colat</span><span class="p">,</span><span class="w"> </span><span class="n">r</span><span class="p">);</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="n">v_gal</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">zdm</span><span class="o">::</span><span class="n">matmul</span><span class="p">(</span><span class="n">rot_equ_to_gal</span><span class="p">,</span><span class="w"> </span><span class="n">v_equ</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">velocity_distribution</span><span class="p">(</span><span class="n">v_gal</span><span class="p">,</span><span class="w"> </span><span class="n">params</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>
</div>
<p>We can then take the Zernike transform of the wrapped distribution</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">zest</span><span class="o">::</span><span class="n">ZernikeTransformerNormalGeo</span><span class="w"> </span><span class="n">zernike_transformer</span><span class="p">{};</span>
<span class="n">zdm</span><span class="o">::</span><span class="n">ZernikeExpansion</span><span class="w"> </span><span class="n">dist</span>
<span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="n">zernike_transformer</span><span class="p">.</span><span class="n">transform</span><span class="p">(</span><span class="n">wrapped_distribution</span><span class="p">,</span><span class="w"> </span><span class="n">v_esc</span><span class="p">,</span><span class="w"> </span><span class="n">dist_order</span><span class="p">);</span>
</pre></div>
</div>
<p>Giving <code class="docutils literal notranslate"><span class="pre">v_esc</span></code> as the second paramter here essentially tells the transformer that the velocity
distribution is zero for velocities greater than the escape velocity, so that it can internally
scale the coordinates to the unit sphere.</p>
</section>
<section id="angle-integrated-radon-transform">
<h2>Angle-integrated Radon transform<a class="headerlink" href="#angle-integrated-radon-transform" title="Link to this heading">¶</a></h2>
<p>We for the most general dark matter event rate, we need both the nontransverse and transverse Radon
transforms, so we choose <a class="reference internal" href="reference.html#_CPPv4N3zdm5zebra36AnisotropicTransverseAngleIntegratorE" title="zdm::zebra::AnisotropicTransverseAngleIntegrator"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">zdm::zebra::AnisotropicTransverseAngleIntegrator</span></code></a></p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">zdm</span><span class="o">::</span><span class="n">zebra</span><span class="o">::</span><span class="n">AnisotropicAngleIntegrator</span><span class="w"> </span><span class="nf">integrator</span><span class="p">(</span><span class="n">dist_order</span><span class="p">,</span><span class="w"> </span><span class="n">resp_order</span><span class="p">);</span>
</pre></div>
</div>
<p>Before we go and compute the angle-integrated Radon transforms, there is one very important thing
to account for. The integral that our <code class="docutils literal notranslate"><span class="pre">integrator</span></code> computes is defined on the unit ball in the
velocity space. In other words, it is computed in a system of units where <span class="math notranslate nohighlight">\(v_\text{esc} = 1\)</span>
by definition. Therefore, we need to scale all our units appropriately. In terms of the input,
this means dividing both <span class="math notranslate nohighlight">\(v_\text{lab}\)</span> and <span class="math notranslate nohighlight">\(v_\text{min}\)</span> by <span class="math notranslate nohighlight">\(v_\text{esc}\)</span></p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">inv_v_esc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.0</span><span class="o">/</span><span class="n">v_esc</span><span class="p">;</span>

<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">u_lab_eq</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v_lab_eq</span><span class="p">;</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">element</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">u_lab_eq</span><span class="p">)</span>
<span class="w">    </span><span class="n">element</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">zdm</span><span class="o">::</span><span class="n">mul</span><span class="p">(</span><span class="n">inv_v_esc</span><span class="p">,</span><span class="w"> </span><span class="n">element</span><span class="p">);</span>

<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">u_min</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v_min</span><span class="p">;</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">element</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">v_min</span><span class="p">)</span>
<span class="w">    </span><span class="n">element</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="n">inv_v_esc</span><span class="p">;</span>
</pre></div>
</div>
<p>Then these are the inputs to the integrator</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">zest</span><span class="o">::</span><span class="n">MDArray</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">out</span><span class="p">({</span><span class="n">v_lab_eq</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span><span class="w"> </span><span class="n">v_min</span><span class="p">.</span><span class="n">size</span><span class="p">()});</span>
<span class="n">integrator</span><span class="p">.</span><span class="n">integrate</span><span class="p">(</span><span class="n">dist</span><span class="p">,</span><span class="w"> </span><span class="n">resp</span><span class="p">,</span><span class="w"> </span><span class="n">u_lab_eq</span><span class="p">,</span><span class="w"> </span><span class="n">era</span><span class="p">,</span><span class="w"> </span><span class="n">u_min</span><span class="p">,</span><span class="w"> </span><span class="n">out</span><span class="p">);</span>
</pre></div>
</div>
<p>Again, we need to account for the units in which the velocity integral was computed. This means
multiplying the nontransverse Radon transform by <span class="math notranslate nohighlight">\(v_\text{esc}^2\)</span> and the transverse Radon
transform by <span class="math notranslate nohighlight">\(v_\text{esc}^4\)</span></p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">v_esc_2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v_esc</span><span class="o">*</span><span class="n">v_esc</span><span class="p">;</span>
<span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">v_esc_4</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v_esc_2</span><span class="o">*</span><span class="n">v_esc_2</span><span class="p">;</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">element</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">out</span><span class="p">.</span><span class="n">flatten</span><span class="p">())</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">element</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="n">v_esc_2</span><span class="p">;</span>
<span class="w">    </span><span class="n">element</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="n">v_esc_4</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="getting-the-event-rates-out">
<h2>Getting the event rates out<a class="headerlink" href="#getting-the-event-rates-out" title="Link to this heading">¶</a></h2>
<p>After this, the output is in our original velocity units. After this it is just a matter of
multiplying by the EFT responses, adding the results together, and multiplying by the common
prefactor.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">eft_responses</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">compute_eft_responses</span><span class="p">(</span><span class="n">momentum_transfers</span><span class="p">);</span>
<span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">prefactor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">event_rate_prefactor</span><span class="p">(</span><span class="n">dm_density</span><span class="p">,</span><span class="w"> </span><span class="n">dm_mass</span><span class="p">,</span><span class="w"> </span><span class="n">nuclear_mass</span><span class="p">);</span>

<span class="n">zdm</span><span class="o">::</span><span class="n">MDArray</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">event_rates</span><span class="p">(</span><span class="n">out</span><span class="p">.</span><span class="n">extents</span><span class="p">());</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">out</span><span class="p">.</span><span class="n">extent</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">out</span><span class="p">.</span><span class="n">extent</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w"> </span><span class="o">++</span><span class="n">j</span><span class="p">)</span>
<span class="w">        </span><span class="n">event_rates</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">prefactor</span><span class="o">*</span><span class="n">zdm</span><span class="o">::</span><span class="n">dot</span><span class="p">(</span><span class="n">eft_responses</span><span class="p">[</span><span class="n">j</span><span class="p">],</span><span class="w"> </span><span class="n">out</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The function <code class="docutils literal notranslate"><span class="pre">event_rate_prefactor</span></code> here is a stand in for the prefactor</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\frac{1}{64\pi^2}\frac{\rho_0}{m_\text{DM}^3m_\text{N}^2}.\]</div>
</div>
</section>
</section>

        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          <a class="next-page" href="reference.html">
              <div class="page-info">
                <div class="context">
                  <span>Next</span>
                </div>
                <div class="title">Library reference</div>
              </div>
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
            </a>
          <a class="prev-page" href="usage.html">
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
              <div class="page-info">
                <div class="context">
                  <span>Previous</span>
                </div>
                
                <div class="title">Usage – Integrating a Radon transform</div>
                
              </div>
            </a>
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 2025, Sebastian Sassi
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            
          </div>
          <div class="right-details">
            
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer">
      
      
      <div class="toc-sticky toc-scroll">
        <div class="toc-title-container">
          <span class="toc-title">
            On this page
          </span>
        </div>
        <div class="toc-tree-container">
          <div class="toc-tree">
            <ul>
<li><a class="reference internal" href="#">Example: DM–nucleon scattering</a><ul>
<li><a class="reference internal" href="#disclaimer">Disclaimer</a></li>
<li><a class="reference internal" href="#inputs">Inputs</a></li>
<li><a class="reference internal" href="#distribution-and-response">Distribution and response</a></li>
<li><a class="reference internal" href="#angle-integrated-radon-transform">Angle-integrated Radon transform</a></li>
<li><a class="reference internal" href="#getting-the-event-rates-out">Getting the event rates out</a></li>
</ul>
</li>
</ul>

          </div>
        </div>
      </div>
      
      
    </aside>
  </div>
</div><script src="_static/documentation_options.js?v=01f34227"></script>
    <script src="_static/doctools.js?v=9bcbadda"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/scripts/furo.js?v=5fa4622c"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    </body>
</html>