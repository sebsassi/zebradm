<!doctype html>
<html class="no-js" lang="en" data-content_root="./">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="index" title="Index" href="genindex.html" /><link rel="search" title="Search" href="search.html" /><link rel="next" title="Example: DM–nucleon scattering" href="dm_example.html" /><link rel="prev" title="Theory – Zernike-based Radon transforms" href="introduction.html" />

    <!-- Generated with Sphinx 8.2.3 and Furo 2024.08.06 -->
        <title>Usage – Integrating a Radon transform - zebradm 0.1.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=8f2a1f02" />
    <link rel="stylesheet" type="text/css" href="_static/styles/furo.css?v=354aac6f" />
    <link rel="stylesheet" type="text/css" href="_static/styles/furo-extensions.css?v=302659d7" />
    
    


<style>
  body {
    --color-code-background: #f8f8f8;
  --color-code-foreground: black;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-with-moon" viewBox="0 0 24 24">
    <title>Auto light/dark, in light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round"
      class="icon-custom-derived-from-feather-sun-and-tabler-moon">
      <path style="opacity: 50%" d="M 5.411 14.504 C 5.471 14.504 5.532 14.504 5.591 14.504 C 3.639 16.319 4.383 19.569 6.931 20.352 C 7.693 20.586 8.512 20.551 9.25 20.252 C 8.023 23.207 4.056 23.725 2.11 21.184 C 0.166 18.642 1.702 14.949 4.874 14.536 C 5.051 14.512 5.231 14.5 5.411 14.5 L 5.411 14.504 Z"/>
      <line x1="14.5" y1="3.25" x2="14.5" y2="1.25"/>
      <line x1="14.5" y1="15.85" x2="14.5" y2="17.85"/>
      <line x1="10.044" y1="5.094" x2="8.63" y2="3.68"/>
      <line x1="19" y1="14.05" x2="20.414" y2="15.464"/>
      <line x1="8.2" y1="9.55" x2="6.2" y2="9.55"/>
      <line x1="20.8" y1="9.55" x2="22.8" y2="9.55"/>
      <line x1="10.044" y1="14.006" x2="8.63" y2="15.42"/>
      <line x1="19" y1="5.05" x2="20.414" y2="3.636"/>
      <circle cx="14.5" cy="9.55" r="3.6"/>
    </svg>
  </symbol>
  <symbol id="svg-moon-with-sun" viewBox="0 0 24 24">
    <title>Auto light/dark, in dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round"
      class="icon-custom-derived-from-feather-sun-and-tabler-moon">
      <path d="M 8.282 7.007 C 8.385 7.007 8.494 7.007 8.595 7.007 C 5.18 10.184 6.481 15.869 10.942 17.24 C 12.275 17.648 13.706 17.589 15 17.066 C 12.851 22.236 5.91 23.143 2.505 18.696 C -0.897 14.249 1.791 7.786 7.342 7.063 C 7.652 7.021 7.965 7 8.282 7 L 8.282 7.007 Z"/>
      <line style="opacity: 50%" x1="18" y1="3.705" x2="18" y2="2.5"/>
      <line style="opacity: 50%" x1="18" y1="11.295" x2="18" y2="12.5"/>
      <line style="opacity: 50%" x1="15.316" y1="4.816" x2="14.464" y2="3.964"/>
      <line style="opacity: 50%" x1="20.711" y1="10.212" x2="21.563" y2="11.063"/>
      <line style="opacity: 50%" x1="14.205" y1="7.5" x2="13.001" y2="7.5"/>
      <line style="opacity: 50%" x1="21.795" y1="7.5" x2="23" y2="7.5"/>
      <line style="opacity: 50%" x1="15.316" y1="10.184" x2="14.464" y2="11.036"/>
      <line style="opacity: 50%" x1="20.711" y1="4.789" x2="21.563" y2="3.937"/>
      <circle style="opacity: 50%" cx="18" cy="7.5" r="2.169"/>
    </svg>
  </symbol>
  <symbol id="svg-pencil" viewBox="0 0 24 24">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-pencil-code">
      <path d="M4 20h4l10.5 -10.5a2.828 2.828 0 1 0 -4 -4l-10.5 10.5v4" />
      <path d="M13.5 6.5l4 4" />
      <path d="M20 21l2 -2l-2 -2" />
      <path d="M17 17l-2 2l2 2" />
    </svg>
  </symbol>
  <symbol id="svg-eye" viewBox="0 0 24 24">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-eye-code">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M10 12a2 2 0 1 0 4 0a2 2 0 0 0 -4 0" />
      <path
        d="M11.11 17.958c-3.209 -.307 -5.91 -2.293 -8.11 -5.958c2.4 -4 5.4 -6 9 -6c3.6 0 6.6 2 9 6c-.21 .352 -.427 .688 -.647 1.008" />
      <path d="M20 21l2 -2l-2 -2" />
      <path d="M17 17l-2 2l2 2" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>

<a class="skip-to-content muted-link" href="#furo-main-content">Skip to content</a>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="index.html"><div class="brand">zebradm 0.1.0 documentation</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
          <svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon no-toc" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand" href="index.html">
  
  
  <span class="sidebar-brand-text">zebradm 0.1.0 documentation</span>
  
</a><form class="sidebar-search-container" method="get" action="search.html" role="search">
  <input class="sidebar-search" placeholder="Search" name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="getting_started.html">Getting started</a></li>
<li class="toctree-l1"><a class="reference internal" href="introduction.html">Theory – Zernike-based Radon transforms</a></li>
<li class="toctree-l1 current current-page"><a class="current reference internal" href="#">Usage – Integrating a Radon transform</a></li>
<li class="toctree-l1"><a class="reference internal" href="dm_example.html">Example: DM–nucleon scattering</a></li>
<li class="toctree-l1"><a class="reference internal" href="reference.html">Library reference</a></li>
</ul>

</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          <div class="view-this-page">
  <a class="muted-link" href="_sources/usage.rst.txt" title="View this page">
    <svg><use href="#svg-eye"></use></svg>
    <span class="visually-hidden">View this page</span>
  </a>
</div>
<div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
              <svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon no-toc" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main" id="furo-main-content">
          <section id="usage-integrating-a-radon-transform">
<h1>Usage – Integrating a Radon transform<a class="headerlink" href="#usage-integrating-a-radon-transform" title="Link to this heading">¶</a></h1>
<p>This section goes through the core parts of the library and its usage via an example of evaluating
the angle-integrated Radon transform of a distribution with a response function.</p>
<p>The angle integration is implemented in four core classes:</p>
<ul class="simple">
<li><p><a class="reference internal" href="reference.html#_CPPv4N3zdm5zebra24IsotropicAngleIntegratorE" title="zdm::zebra::IsotropicAngleIntegrator"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">zdm::zebra::IsotropicAngleIntegrator</span></code></a></p></li>
<li><p><a class="reference internal" href="reference.html#_CPPv4N3zdm5zebra26AnisotropicAngleIntegratorE" title="zdm::zebra::AnisotropicAngleIntegrator"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">zdm::zebra::AnisotropicAngleIntegrator</span></code></a></p></li>
<li><p><a class="reference internal" href="reference.html#_CPPv4N3zdm5zebra34IsotropicTransverseAngleIntegratorE" title="zdm::zebra::IsotropicTransverseAngleIntegrator"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">zdm::zebra::IsotropicTransverseAngleIntegrator</span></code></a></p></li>
<li><p><a class="reference internal" href="reference.html#_CPPv4N3zdm5zebra36AnisotropicTransverseAngleIntegratorE" title="zdm::zebra::AnisotropicTransverseAngleIntegrator"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">zdm::zebra::AnisotropicTransverseAngleIntegrator</span></code></a></p></li>
</ul>
<p>The classes with <code class="docutils literal notranslate"><span class="pre">Transverse</span></code> compute the angle-integrated transverse Radon transform in addition
to the nontransverse case, whereas the others only compute the nontransverse case. The classes
marked with <code class="docutils literal notranslate"><span class="pre">Anisotropic</span></code> are used when we have an anisotropic response function, whereas the
<code class="docutils literal notranslate"><span class="pre">Isotropic</span></code> classes are for the special case where the response function is istropic (or,
alternatively, when we have no response function).</p>
<p>We will mainly consider <a class="reference internal" href="reference.html#_CPPv4N3zdm5zebra26AnisotropicAngleIntegratorE" title="zdm::zebra::AnisotropicAngleIntegrator"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">zdm::zebra::AnisotropicAngleIntegrator</span></code></a> here. The isotropic
integrators are simpler, because they don’t need to deal with the presence of a response function,
and the transverse integrators in turn essentially only differ by the fact that they return two
numbers where the nontransverse integrators return one.</p>
<p>The first order of business is to initialize our integrator</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;zebradm/zebra_angle_integrator.hpp&gt;</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">constexpr</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="w"> </span><span class="n">dist_order</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">30</span><span class="p">;</span>
<span class="w">    </span><span class="k">constexpr</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="w"> </span><span class="n">resp_order</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">60</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// ...</span>

<span class="w">    </span><span class="n">zdm</span><span class="o">::</span><span class="n">zebra</span><span class="o">::</span><span class="n">AnisotropicAngleIntegrator</span><span class="w"> </span><span class="n">integrator</span><span class="p">(</span><span class="n">dist_order</span><span class="p">,</span><span class="w"> </span><span class="n">resp_order</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// ...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>All the integrators are located in the header <code class="docutils literal notranslate"><span class="pre">zebradm/zebra_angle_integrator.hpp</span></code>. The
parameters <code class="docutils literal notranslate"><span class="pre">dist_order</span></code> and <code class="docutils literal notranslate"><span class="pre">resp_order</span></code> are the orders of the Zernike and spherical harmonic
expansions of the distribution and response functions, respectively. One can also default
initialize the integrator</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">zdm</span><span class="o">::</span><span class="n">zebra</span><span class="o">::</span><span class="n">AnisotropicAngleIntegrator</span><span class="w"> </span><span class="n">integrator</span><span class="p">{};</span>
</pre></div>
</div>
<p>Initializing with the order parameter preallocates some buffers. However, when the integrator is
used, it will also read these paramters off the expansions it is given, and adjust its buffers
accordingly, so whether to use default initialization or not is a matter of preference.</p>
<p>In order to use the integrator, we will need to prepare the data needed to compute the Radon
transform. First and foremost, we need a Zernike expansion representing our distribution function.
Typically, the Zernike expansion is computed from some mathematical expression for the
distribution, so we will define one</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cmath&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;array&gt;</span>

<span class="k">constexpr</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="n">var</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mf">0.5</span><span class="p">,</span><span class="w"> </span><span class="mf">0.6</span><span class="p">,</span><span class="w"> </span><span class="mf">0.7</span><span class="p">};</span>
<span class="k">auto</span><span class="w"> </span><span class="n">dist_func</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="kt">double</span><span class="w"> </span><span class="n">lon</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">colat</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">r</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">r</span><span class="o">*</span><span class="nf">std::sin</span><span class="p">(</span><span class="n">colat</span><span class="p">)</span><span class="o">*</span><span class="n">std</span><span class="o">::</span><span class="n">cos</span><span class="p">(</span><span class="n">lon</span><span class="p">),</span>
<span class="w">        </span><span class="n">r</span><span class="o">*</span><span class="n">std</span><span class="o">::</span><span class="n">sin</span><span class="p">(</span><span class="n">colat</span><span class="p">)</span><span class="o">*</span><span class="n">std</span><span class="o">::</span><span class="n">sin</span><span class="p">(</span><span class="n">lon</span><span class="p">),</span>
<span class="w">        </span><span class="n">r</span><span class="o">*</span><span class="n">std</span><span class="o">::</span><span class="n">cos</span><span class="p">(</span><span class="n">colat</span><span class="p">)</span>
<span class="w">    </span><span class="p">};</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">var</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">var</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">/</span><span class="n">var</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
<span class="p">};</span>
</pre></div>
</div>
<p>This is a C++ lambda function describing an anisotropic Gaussian distribution. The function takes
three doubles denoting the three spherical coordinates. The distribution function must have either
this signature, or an alternative signature which takes a single <code class="docutils literal notranslate"><span class="pre">std::array&lt;double,</span> <span class="pre">3&gt;</span></code>,
denoting the Cartesian three-vector <code class="docutils literal notranslate"><span class="pre">x</span></code>. Defining the distribution function as a lambda, because
additional parameters can be taken as captures, as is the case with <code class="docutils literal notranslate"><span class="pre">dispersion</span></code> here.</p>
<p>The business of Zernike and spherical harmonic transforms and expansions is handled by the library
<a class="reference external" href="https://github.com/sebsassi/zest">zest</a>. We can use zest’s <code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">zest::zt::ZernikeTransformer</span></code>
to accomplish this. As a more general purpose library, zest supports multiple conventions for
normalization and the Condon–Shortley phase. In ZebraDM the conventions are chosen to be such that
the spherical harmonics are <span class="math notranslate nohighlight">\(4\pi\)</span>-normalized and defined without the Condon–Shortley phase,
and the radial Zernike polynomials are fully normalized. Multiple aliases of the basic types are
defined by zest for different combinations of conventions, and so the correct transformer for
Zernike expansions compatible with ZebraDM is <code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">zest::zt::ZernikeTransformerNormalGeo</span></code>.
We can use this to easily get the Zernike expansion of our distribution</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;zest/zernike_glq_transformer.hpp&gt;</span>

<span class="k">constexpr</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">radius</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">2.0</span><span class="p">;</span>
<span class="n">zest</span><span class="o">::</span><span class="n">zt</span><span class="o">::</span><span class="n">RealZernikeExpansionNormalGeo</span><span class="w"> </span><span class="n">zernike_transformer</span><span class="p">{};</span>
<span class="n">zest</span><span class="o">::</span><span class="n">zt</span><span class="o">::</span><span class="n">RealZernikeExpansionNormalGeo</span><span class="w"> </span><span class="n">distribution</span>
<span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="n">zernike_transformer</span><span class="p">{}.</span><span class="n">transform</span><span class="p">(</span><span class="n">dist_func</span><span class="p">,</span><span class="w"> </span><span class="n">radius</span><span class="p">,</span><span class="w"> </span><span class="n">dist_order</span><span class="p">);</span>
</pre></div>
</div>
<p>The Zernike functions are defined on the unit ball, but we can obviously scale any ball to a unit
ball. The <code class="docutils literal notranslate"><span class="pre">radius</span></code> parameter here does exactly that. It is the radius of the ball on which our
function is defined, so that <code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">zest::zt::ZernikeTransformer</span></code> can do the scaling for you.</p>
<p>The next problem is to define our response function. For purposes of this demonstration, we use an
arbitrary function</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">constexpr</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mf">0.5</span><span class="p">,</span><span class="w"> </span><span class="mf">0.5</span><span class="p">,</span><span class="w"> </span><span class="mf">0.5</span><span class="p">};</span>
<span class="k">auto</span><span class="w"> </span><span class="n">resp_func</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="kt">double</span><span class="w"> </span><span class="n">shell</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">lon</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">colat</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="n">dir</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">sin</span><span class="p">(</span><span class="n">colat</span><span class="p">)</span><span class="o">*</span><span class="n">std</span><span class="o">::</span><span class="n">cos</span><span class="p">(</span><span class="n">lon</span><span class="p">),</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">sin</span><span class="p">(</span><span class="n">colat</span><span class="p">)</span><span class="o">*</span><span class="n">std</span><span class="o">::</span><span class="n">sin</span><span class="p">(</span><span class="n">lon</span><span class="p">),</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cos</span><span class="p">(</span><span class="n">colat</span><span class="p">)</span>
<span class="w">    </span><span class="p">};</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">min_speed</span><span class="o">*</span><span class="p">(</span><span class="n">zdm</span><span class="o">::</span><span class="n">linalg</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">)));</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The argument <code class="docutils literal notranslate"><span class="pre">shell</span></code> here is same as the shell parameter <span class="math notranslate nohighlight">\(w\)</span> (see the section on
theoretical background), which in dark matter direct detection literature is often denoted
<span class="math notranslate nohighlight">\(v_\text{min}\)</span>. In nuclear scattering of dark matter this is the minimum speed needed from
dark matter to give the nucleus recoil momentum equal to the momentum transfer.</p>
<p>The angle-integrated Radon transform in this library is defined on a collection of shell
parameters. We therefore need to decide upon the collection of shell parameters. As discussed in
the theoretical background section, the geometry of the situation means that if our distribution
has offset <span class="math notranslate nohighlight">\(\vec{x}_0\)</span>, then the angle-integrated Radon transform goes to zero for
<span class="math notranslate nohighlight">\(w &gt; 1 + x_0\)</span>. Therefore, to determine an appropriate maximum value for the shell parameter,
we will need to determine our offsets. In a real problem the offsets would come from somewhere. For
example, in the context of dark matter direct detection they are the velocities of the laboratory
relative to the dark matter distribution. For purposes of this example, we will generate a random
list of vectors of some length</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;random&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;vector&gt;</span>

<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">generate_offsets</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="w"> </span><span class="n">count</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">offset_len</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">mt19937</span><span class="w"> </span><span class="n">gen</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">uniform_real_distribution</span><span class="w"> </span><span class="n">rng_dist</span><span class="p">{</span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="p">};</span>

<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">offsets</span><span class="p">(</span><span class="n">count</span><span class="p">);</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">count</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">ct</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">2.0</span><span class="o">*</span><span class="n">rng_dist</span><span class="p">(</span><span class="n">gen</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mf">1.0</span><span class="p">;</span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">st</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">sqrt</span><span class="p">((</span><span class="mf">1.0</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">ct</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mf">1.0</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">ct</span><span class="p">));</span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">az</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">2.0</span><span class="o">*</span><span class="n">std</span><span class="o">::</span><span class="n">numbers</span><span class="o">::</span><span class="n">pi</span><span class="o">*</span><span class="n">rng_dist</span><span class="p">(</span><span class="n">gen</span><span class="p">);</span>
<span class="w">        </span><span class="n">offsets</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="n">offset_len</span><span class="o">*</span><span class="n">st</span><span class="o">*</span><span class="n">std</span><span class="o">::</span><span class="n">cos</span><span class="p">(</span><span class="n">az</span><span class="p">),</span><span class="w"> </span><span class="n">offset_len</span><span class="o">*</span><span class="n">st</span><span class="o">*</span><span class="n">std</span><span class="o">::</span><span class="n">sin</span><span class="p">(</span><span class="n">az</span><span class="p">),</span><span class="w"> </span><span class="n">ct</span><span class="p">};</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">offsets</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Alongside this, we can create a similar function that generates a vector of shell parameters</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">generate_shells</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="w"> </span><span class="n">count</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">offset_len</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">max_shell</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.0</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">offset_len</span><span class="p">;</span>

<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">shells</span><span class="p">(</span><span class="n">count</span><span class="p">);</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">count</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="w">        </span><span class="n">shells</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">max_shell</span><span class="o">*</span><span class="kt">double</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">/</span><span class="kt">double</span><span class="p">(</span><span class="n">count</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">shells</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Then we can generate the offsets and shells</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">constexpr</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">offset_len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.5</span><span class="p">;</span>
<span class="k">constexpr</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">offset_count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span>
<span class="k">constexpr</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">shell_count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">50</span><span class="p">;</span>

<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">offsets</span>
<span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="n">generate_offsets</span><span class="p">(</span><span class="n">offset_count</span><span class="p">,</span><span class="w"> </span><span class="n">offset_len</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">shells</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">generate_shells</span><span class="p">(</span><span class="n">shell_count</span><span class="p">,</span><span class="w"> </span><span class="n">offset_len</span><span class="p">);</span>
</pre></div>
</div>
<p>Now that we actually have the shells, we can compute the spherical harmonic transforms of the
shells on the response functions. For this purpose, the header <code class="docutils literal notranslate"><span class="pre">zebradm/zebra_util.hpp</span></code> provides
the container <a class="reference internal" href="reference.html#_CPPv4N3zdm17SHExpansionVectorE" title="zdm::SHExpansionVector"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">zdm::SHExpansionVector</span></code></a> for storing a collection of spherical harmonic
expansions in a single buffer, as well as the class <a class="reference internal" href="reference.html#_CPPv4N3zdm5zebra19ResponseTransformerE" title="zdm::zebra::ResponseTransformer"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">zdm::zebra::ResponseTransformer</span></code></a>
for computing the spherical harmonic expansions.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">zdm</span><span class="o">::</span><span class="n">zebra</span><span class="o">::</span><span class="n">ResponseTransformer</span><span class="w"> </span><span class="n">response_transformer</span><span class="p">{};</span>
<span class="n">zdm</span><span class="o">::</span><span class="n">SHExpansionVector</span><span class="w"> </span><span class="n">response</span>
<span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="n">response_transformer</span><span class="p">.</span><span class="n">transform</span><span class="p">(</span><span class="n">resp_func</span><span class="p">,</span><span class="w"> </span><span class="n">shells</span><span class="p">,</span><span class="w"> </span><span class="n">resp_order</span><span class="p">);</span>
</pre></div>
</div>
<p>At this point we are almost ready to use the integrator. We still need two things, however. First
is a vector of rotation angles for each offset, because not only can the distribution be defined in
coordinates with an arbitrary offset, but it can also have a rotation relative to the coordinates
in which the response is defined.</p>
<p>In principle, the distribution and response functions could be defined in coordinate systems which
differ from each other by an arbitrary 3D rotation. However, arbitrary 3D rotations of spherical
harmonic expansions are expensive, so the transformer has been limited to doing rotations about the
z-axis per offset. With that said, nothing stops you from applying arbitrary global rotations on
the expansions of the distribution and response before handing them off to the integrator. You can
rotate Zernike and spherical harmonic transforms by arbitrary Euler angles with the
<code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">zest::Rotor</span></code> class</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;numbers&gt;</span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;zest/rotor.hpp&gt;</span>

<span class="n">zest</span><span class="o">::</span><span class="n">WignerdPiHalfCollection</span><span class="w"> </span><span class="nf">wigner</span><span class="p">(</span><span class="n">resp_order</span><span class="p">);</span>
<span class="n">zest</span><span class="o">::</span><span class="n">Rotor</span><span class="w"> </span><span class="nf">rotor</span><span class="p">(</span><span class="n">resp_order</span><span class="p">);</span>
<span class="k">constexpr</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="n">euler_angles</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">numbers</span><span class="o">::</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">numbers</span><span class="o">::</span><span class="n">pi</span><span class="o">/</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">numbers</span><span class="o">::</span><span class="n">pi</span><span class="o">/</span><span class="mi">4</span>
<span class="p">};</span>

<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">response</span><span class="p">.</span><span class="n">extent</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="w">    </span><span class="n">rotor</span><span class="p">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">response</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="w"> </span><span class="n">wigner</span><span class="p">,</span><span class="w"> </span><span class="n">euler_angles</span><span class="p">,</span><span class="w"> </span><span class="n">zest</span><span class="o">::</span><span class="n">RotatioType</span><span class="o">::</span><span class="n">coordinate</span><span class="p">);</span>
</pre></div>
</div>
<p>The variable <code class="docutils literal notranslate"><span class="pre">wigner</span></code> holds some constant Wigner D-matrices needed for the rotation. The last
argument in turn tells the rotor whether we are rotating the coordinate system (active), or the
object (passive). You can read more about this in the zest documentation.</p>
<p>With that said, here we can just create a nice full rotation</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">generate_rotation_angles</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="w"> </span><span class="n">offset_count</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">rotation_angles</span><span class="p">(</span><span class="n">offset_count</span><span class="p">);</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">offset_count</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="w">        </span><span class="n">rotation_angles</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
<span class="w">            </span><span class="o">=</span><span class="w"> </span><span class="mf">2.0</span><span class="o">*</span><span class="n">std</span><span class="o">::</span><span class="n">numbers</span><span class="o">::</span><span class="n">pi</span><span class="o">*</span><span class="kt">double</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">/</span><span class="kt">double</span><span class="p">(</span><span class="n">offset_count</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">rotation_angles</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>and then generate the rotation angles</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">rotation_angles</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">generate_rotation_angles</span><span class="p">(</span><span class="n">offset_count</span><span class="p">);</span>
</pre></div>
</div>
<p>Now, the last remaining thing we need is a buffer to put the results in</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;zest/md_array.hpp&gt;</span>

<span class="n">zest</span><span class="o">::</span><span class="n">MDArray</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">out</span><span class="p">({</span><span class="n">offset_count</span><span class="p">,</span><span class="w"> </span><span class="n">shell_count</span><span class="p">});</span>
</pre></div>
</div>
<p>If we were dealing with one of the <code class="docutils literal notranslate"><span class="pre">Transverse</span></code> integrators, then then we would have to use
<code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">std::array&lt;double,</span> <span class="pre">2&gt;</span></code> as the element type of <code class="docutils literal notranslate"><span class="pre">out</span></code> instead to store the
nontransverse–transverse pair.</p>
<p>With this, we finally have everything in place to integrate the angle-integrated Radon transform</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">integrator</span><span class="p">.</span><span class="n">integrate</span><span class="p">(</span>
<span class="w">        </span><span class="n">distribution</span><span class="p">,</span><span class="w"> </span><span class="n">response</span><span class="p">,</span><span class="w"> </span><span class="n">offsets</span><span class="p">,</span><span class="w"> </span><span class="n">rotation_angles</span><span class="p">,</span><span class="w"> </span><span class="n">shells</span><span class="p">,</span><span class="w"> </span><span class="n">out</span><span class="p">);</span>
</pre></div>
</div>
<p>Now, this is almost it. However, there is one point which need to be accounted for. Earlier we set
the parameter <code class="docutils literal notranslate"><span class="pre">radius</span> <span class="pre">=</span> <span class="pre">2.0</span></code> indicating to the Zernike transformer that our distribution is
defined in a ball of radius two. However, the Radon transform is always evaluated on the unit ball.
This means that if we defined the unit ball coordinates <span class="math notranslate nohighlight">\(\vec{x} = \vec{r}/R\)</span>, where <span class="math notranslate nohighlight">\(R\)</span>
is our radius, then</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\mathcal{R}[f](w,\hat{n})
    = \int\delta(\vec{r}\cdot\hat{n} - w)f(\vec{r})\,d^3r = R^2\int\delta(\vec{x}\cdot\hat{n} - w/R)f(R\vec{x})\,d^3x.\]</div>
</div>
<p>That is, in practice, not only do we need to divide our original shell parameters by the radius
(which we didn’t do here because we just generated the scaled parameters directly), but we also
have to multiply our result by the radius squared</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">element</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">out</span><span class="p">.</span><span class="n">flatten</span><span class="p">())</span>
<span class="w">    </span><span class="n">element</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="n">radius</span><span class="o">*</span><span class="n">radius</span><span class="p">;</span>
</pre></div>
</div>
<p>If we were also evaluating the transverse Radon transform, we would likewise have to multiply it by
the fourth power of the radius.</p>
<p>And this is it. We have successfully computed the angle-integrated Radon transform of of our
distribution, combined with an anisotropic response function, for a set of shells and offset–angle
pairs. In summary, here is the full source code of our program</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;array&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;vector&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cmath&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;numbers&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;random&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cstdio&gt;</span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;zest/zernike_glq_transformer.hpp&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;zest/md_array.hpp&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;zest/rotor.hpp&gt;</span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;zebradm/zebra_angle_integrator.hpp&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;zebradm/linalg.hpp&gt;</span>

<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="o">&gt;&gt;</span>
<span class="n">generate_offsets</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="w"> </span><span class="n">count</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">offset_len</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">mt19937</span><span class="w"> </span><span class="n">gen</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">uniform_real_distribution</span><span class="w"> </span><span class="n">rng_dist</span><span class="p">{</span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="p">};</span>

<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">offsets</span><span class="p">(</span><span class="n">count</span><span class="p">);</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">count</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">ct</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">2.0</span><span class="o">*</span><span class="n">rng_dist</span><span class="p">(</span><span class="n">gen</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mf">1.0</span><span class="p">;</span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">st</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">sqrt</span><span class="p">((</span><span class="mf">1.0</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">ct</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mf">1.0</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">ct</span><span class="p">));</span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">az</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">2.0</span><span class="o">*</span><span class="n">std</span><span class="o">::</span><span class="n">numbers</span><span class="o">::</span><span class="n">pi</span><span class="o">*</span><span class="n">rng_dist</span><span class="p">(</span><span class="n">gen</span><span class="p">);</span>
<span class="w">        </span><span class="n">offsets</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="n">offset_len</span><span class="o">*</span><span class="n">st</span><span class="o">*</span><span class="n">std</span><span class="o">::</span><span class="n">cos</span><span class="p">(</span><span class="n">az</span><span class="p">),</span><span class="w"> </span><span class="n">offset_len</span><span class="o">*</span><span class="n">st</span><span class="o">*</span><span class="n">std</span><span class="o">::</span><span class="n">sin</span><span class="p">(</span><span class="n">az</span><span class="p">),</span><span class="w"> </span><span class="n">ct</span><span class="p">};</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">offsets</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">generate_rotation_angles</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="w"> </span><span class="n">offset_count</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">rotation_angles</span><span class="p">(</span><span class="n">offset_count</span><span class="p">);</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">offset_count</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="w">        </span><span class="n">rotation_angles</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
<span class="w">            </span><span class="o">=</span><span class="w"> </span><span class="mf">2.0</span><span class="o">*</span><span class="n">std</span><span class="o">::</span><span class="n">numbers</span><span class="o">::</span><span class="n">pi</span><span class="o">*</span><span class="kt">double</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">/</span><span class="kt">double</span><span class="p">(</span><span class="n">offset_count</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">rotation_angles</span><span class="p">;</span>
<span class="p">}</span>


<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">generate_shells</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="w"> </span><span class="n">count</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">offset_len</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">max_shell</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.0</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">offset_len</span><span class="p">;</span>

<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">shells</span><span class="p">(</span><span class="n">count</span><span class="p">);</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">count</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="w">        </span><span class="n">shells</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">max_shell</span><span class="o">*</span><span class="kt">double</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">/</span><span class="kt">double</span><span class="p">(</span><span class="n">count</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">shells</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">constexpr</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="n">var</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mf">0.5</span><span class="p">,</span><span class="w"> </span><span class="mf">0.6</span><span class="p">,</span><span class="w"> </span><span class="mf">0.7</span><span class="p">};</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">dist_func</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="kt">double</span><span class="w"> </span><span class="n">lon</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">colat</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">r</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">r</span><span class="o">*</span><span class="nf">std::sin</span><span class="p">(</span><span class="n">colat</span><span class="p">)</span><span class="o">*</span><span class="n">std</span><span class="o">::</span><span class="n">cos</span><span class="p">(</span><span class="n">lon</span><span class="p">),</span>
<span class="w">            </span><span class="n">r</span><span class="o">*</span><span class="n">std</span><span class="o">::</span><span class="n">sin</span><span class="p">(</span><span class="n">colat</span><span class="p">)</span><span class="o">*</span><span class="n">std</span><span class="o">::</span><span class="n">sin</span><span class="p">(</span><span class="n">lon</span><span class="p">),</span>
<span class="w">            </span><span class="n">r</span><span class="o">*</span><span class="n">std</span><span class="o">::</span><span class="n">cos</span><span class="p">(</span><span class="n">colat</span><span class="p">)</span>
<span class="w">        </span><span class="p">};</span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">var</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">var</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">/</span><span class="n">var</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
<span class="w">    </span><span class="p">};</span>

<span class="w">    </span><span class="k">constexpr</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mf">0.5</span><span class="p">,</span><span class="w"> </span><span class="mf">0.5</span><span class="p">,</span><span class="w"> </span><span class="mf">0.5</span><span class="p">};</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">resp_func</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="kt">double</span><span class="w"> </span><span class="n">shell</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">lon</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">colat</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="n">dir</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">std</span><span class="o">::</span><span class="n">sin</span><span class="p">(</span><span class="n">colat</span><span class="p">)</span><span class="o">*</span><span class="n">std</span><span class="o">::</span><span class="n">cos</span><span class="p">(</span><span class="n">lon</span><span class="p">),</span>
<span class="w">            </span><span class="n">std</span><span class="o">::</span><span class="n">sin</span><span class="p">(</span><span class="n">colat</span><span class="p">)</span><span class="o">*</span><span class="n">std</span><span class="o">::</span><span class="n">sin</span><span class="p">(</span><span class="n">lon</span><span class="p">),</span>
<span class="w">            </span><span class="n">std</span><span class="o">::</span><span class="n">cos</span><span class="p">(</span><span class="n">colat</span><span class="p">)</span>
<span class="w">        </span><span class="p">};</span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">shell</span><span class="o">*</span><span class="p">(</span><span class="n">zdm</span><span class="o">::</span><span class="n">dot</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">)));</span>
<span class="w">    </span><span class="p">};</span>

<span class="w">    </span><span class="k">constexpr</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">offset_len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.5</span><span class="p">;</span>
<span class="w">    </span><span class="k">constexpr</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="w"> </span><span class="n">offset_count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span>
<span class="w">    </span><span class="k">constexpr</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="w"> </span><span class="n">shell_count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">50</span><span class="p">;</span>

<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">offsets</span>
<span class="w">        </span><span class="o">=</span><span class="w"> </span><span class="n">generate_offsets</span><span class="p">(</span><span class="n">offset_count</span><span class="p">,</span><span class="w"> </span><span class="n">offset_len</span><span class="p">);</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">rotation_angles</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">generate_rotation_angles</span><span class="p">(</span><span class="n">offset_count</span><span class="p">);</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">shells</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">generate_shells</span><span class="p">(</span><span class="n">shell_count</span><span class="p">,</span><span class="w"> </span><span class="n">offset_len</span><span class="p">);</span>

<span class="w">    </span><span class="k">constexpr</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">radius</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">2.0</span><span class="p">;</span>
<span class="w">    </span><span class="k">constexpr</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="w"> </span><span class="n">dist_order</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">30</span><span class="p">;</span>
<span class="w">    </span><span class="n">zest</span><span class="o">::</span><span class="n">zt</span><span class="o">::</span><span class="n">ZernikeTransformerNormalGeo</span><span class="w"> </span><span class="n">zernike_transformer</span><span class="p">{};</span>
<span class="w">    </span><span class="n">zest</span><span class="o">::</span><span class="n">zt</span><span class="o">::</span><span class="n">RealZernikeExpansionNormalGeo</span><span class="w"> </span><span class="n">distribution</span>
<span class="w">        </span><span class="o">=</span><span class="w"> </span><span class="n">zernike_transformer</span><span class="p">.</span><span class="n">transform</span><span class="p">(</span><span class="n">dist_func</span><span class="p">,</span><span class="w"> </span><span class="n">radius</span><span class="p">,</span><span class="w"> </span><span class="n">dist_order</span><span class="p">);</span>

<span class="w">    </span><span class="k">constexpr</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="w"> </span><span class="n">resp_order</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">60</span><span class="p">;</span>
<span class="w">    </span><span class="n">zdm</span><span class="o">::</span><span class="n">zebra</span><span class="o">::</span><span class="n">ResponseTransformer</span><span class="w"> </span><span class="n">response_transformer</span><span class="p">{};</span>
<span class="w">    </span><span class="n">zdm</span><span class="o">::</span><span class="n">SHExpansionVector</span><span class="w"> </span><span class="n">response</span>
<span class="w">        </span><span class="o">=</span><span class="w"> </span><span class="n">response_transformer</span><span class="p">.</span><span class="n">transform</span><span class="p">(</span><span class="n">resp_func</span><span class="p">,</span><span class="w"> </span><span class="n">shells</span><span class="p">,</span><span class="w"> </span><span class="n">resp_order</span><span class="p">);</span>

<span class="w">    </span><span class="k">constexpr</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="n">euler_angles</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">numbers</span><span class="o">::</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">numbers</span><span class="o">::</span><span class="n">pi</span><span class="o">/</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">numbers</span><span class="o">::</span><span class="n">pi</span><span class="o">/</span><span class="mi">4</span>
<span class="w">    </span><span class="p">};</span>

<span class="w">    </span><span class="n">zest</span><span class="o">::</span><span class="n">WignerdPiHalfCollection</span><span class="w"> </span><span class="nf">wigner</span><span class="p">(</span><span class="n">resp_order</span><span class="p">);</span>
<span class="w">    </span><span class="n">zest</span><span class="o">::</span><span class="n">Rotor</span><span class="w"> </span><span class="nf">rotor</span><span class="p">(</span><span class="n">resp_order</span><span class="p">);</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">response</span><span class="p">.</span><span class="n">extent</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="w">        </span><span class="n">rotor</span><span class="p">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">response</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="w"> </span><span class="n">wigner</span><span class="p">,</span><span class="w"> </span><span class="n">euler_angles</span><span class="p">,</span><span class="w"> </span><span class="n">zest</span><span class="o">::</span><span class="n">RotationType</span><span class="o">::</span><span class="n">coordinate</span><span class="p">);</span>

<span class="w">    </span><span class="n">zdm</span><span class="o">::</span><span class="n">zebra</span><span class="o">::</span><span class="n">AnisotropicAngleIntegrator</span><span class="w"> </span><span class="nf">integrator</span><span class="p">(</span><span class="n">dist_order</span><span class="p">,</span><span class="w"> </span><span class="n">resp_order</span><span class="p">);</span>

<span class="w">    </span><span class="n">zest</span><span class="o">::</span><span class="n">MDArray</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">out</span><span class="p">({</span><span class="n">offset_count</span><span class="p">,</span><span class="w"> </span><span class="n">shell_count</span><span class="p">});</span>
<span class="w">    </span><span class="n">integrator</span><span class="p">.</span><span class="n">integrate</span><span class="p">(</span>
<span class="w">            </span><span class="n">distribution</span><span class="p">,</span><span class="w"> </span><span class="n">response</span><span class="p">,</span><span class="w"> </span><span class="n">offsets</span><span class="p">,</span><span class="w"> </span><span class="n">rotation_angles</span><span class="p">,</span><span class="w"> </span><span class="n">shells</span><span class="p">,</span><span class="w"> </span><span class="n">out</span><span class="p">);</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">element</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">out</span><span class="p">.</span><span class="n">flatten</span><span class="p">())</span>
<span class="w">        </span><span class="n">element</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="n">radius</span><span class="o">*</span><span class="n">radius</span><span class="p">;</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">out</span><span class="p">.</span><span class="n">extent</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">out</span><span class="p">.</span><span class="n">extent</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="w"> </span><span class="o">++</span><span class="n">j</span><span class="p">)</span>
<span class="w">            </span><span class="n">std</span><span class="o">::</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%.7e&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">out</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">));</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</section>

        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          <a class="next-page" href="dm_example.html">
              <div class="page-info">
                <div class="context">
                  <span>Next</span>
                </div>
                <div class="title">Example: DM–nucleon scattering</div>
              </div>
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
            </a>
          <a class="prev-page" href="introduction.html">
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
              <div class="page-info">
                <div class="context">
                  <span>Previous</span>
                </div>
                
                <div class="title">Theory – Zernike-based Radon transforms</div>
                
              </div>
            </a>
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 2025, Sebastian Sassi
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            
          </div>
          <div class="right-details">
            
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer no-toc">
      
      
      
    </aside>
  </div>
</div><script src="_static/documentation_options.js?v=01f34227"></script>
    <script src="_static/doctools.js?v=9bcbadda"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/scripts/furo.js?v=5fa4622c"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    </body>
</html>